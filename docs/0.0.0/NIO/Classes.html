<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Classes  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset="utf-8">
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
    <script src="js/lunr.min.js" defer></script>
    <script src="js/typeahead.jquery.js" defer></script>
    <script src="js/jazzy.search.js" defer></script>
  </head>
  <body>


    <a title="Classes  Reference"></a>

    <header class="header">
      <p class="header-col header-col--primary">
        <a class="header-link" href="index.html">
          NIO Docs
        </a>
         (89% documented)
      </p>
    
      <p class="header-col--secondary">
        <form role="search" action="search.json">
          <input type="text" placeholder="Search documentation" data-typeahead>
        </form>
      </p>
    
        <p class="header-col header-col--secondary">
          <a class="header-link" href="https://github.com/apple/swift-nio">
            <img class="header-icon" src="img/gh.png"/>
            View on GitHub
          </a>
        </p>
    
    </header>

    <p class="breadcrumbs">
      <a class="breadcrumb" href="index.html">NIO Reference</a>
      <img class="carat" src="img/carat.png" />
      Classes  Reference
    </p>

    <div class="content-wrapper">
      <nav class="navigation">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/BackPressureHandler.html">BackPressureHandler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/BlockingIOThreadPool.html">BlockingIOThreadPool</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/BlockingIOThreadPool/WorkItemState.html">– WorkItemState</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/ChannelHandlerContext.html">ChannelHandlerContext</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/ChannelPipeline.html">ChannelPipeline</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/ClientBootstrap.html">ClientBootstrap</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/DatagramBootstrap.html">DatagramBootstrap</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/EmbeddedChannel.html">EmbeddedChannel</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/EmbeddedEventLoop.html">EmbeddedEventLoop</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/EventLoopFuture.html">EventLoopFuture</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/FileHandle.html">FileHandle</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/IdleStateHandler.html">IdleStateHandler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/MultiThreadedEventLoopGroup.html">MultiThreadedEventLoopGroup</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/ServerBootstrap.html">ServerBootstrap</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/AllocatorOption.html">AllocatorOption</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/AllowRemoteHalfClosureOption.html">AllowRemoteHalfClosureOption</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/AutoReadOption.html">AutoReadOption</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/BacklogOption.html">BacklogOption</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/ChannelError.html">ChannelError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/ChannelEvent.html">ChannelEvent</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/ChannelPipelineError.html">ChannelPipelineError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/CloseMode.html">CloseMode</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/ConnectTimeoutOption.html">ConnectTimeoutOption</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/DecodingState.html">DecodingState</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/Endianness.html">Endianness</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/EventLoopError.html">EventLoopError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/IOData.html">IOData</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/IOEvent.html">IOEvent</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/IOResult.html">IOResult</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/MaxMessagesPerReadOption.html">MaxMessagesPerReadOption</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/RecvAllocatorOption.html">RecvAllocatorOption</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/SocketAddress.html">SocketAddress</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/SocketAddress/IPv4Address.html">– IPv4Address</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/SocketAddress/IPv6Address.html">– IPv6Address</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/SocketAddress/UnixSocketAddress.html">– UnixSocketAddress</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/SocketAddressError.html">SocketAddressError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/SocketOption.html">SocketOption</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/System.html">System</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/WriteBufferWaterMarkOption.html">WriteBufferWaterMarkOption</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/WriteSpinOption.html">WriteSpinOption</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/EmbeddedScheduledTask.html">EmbeddedScheduledTask</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/LinuxCPUSet.html">LinuxCPUSet</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/ScheduledTask.html">ScheduledTask</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/StaticString.html">StaticString</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/Thread.html">Thread</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/UInt32.html">UInt32</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/UInt64.html">UInt64</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/UnsafeBufferPointer.html">UnsafeBufferPointer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/UnsafeMutableRawBufferPointer.html">UnsafeMutableRawBufferPointer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/UnsafeMutableRawPointer.html">UnsafeMutableRawPointer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/UnsafeRawBufferPointer.html">UnsafeRawBufferPointer</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/AppendableCollection.html">AppendableCollection</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ByteToMessageDecoder.html">ByteToMessageDecoder</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/Channel.html">Channel</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ChannelCore.html">ChannelCore</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ChannelHandler.html">ChannelHandler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ChannelInboundHandler.html">ChannelInboundHandler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ChannelInboundInvoker.html">ChannelInboundInvoker</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols.html#/s:3NIO14ChannelInvokerP">ChannelInvoker</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ChannelOption.html">ChannelOption</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ChannelOutboundHandler.html">ChannelOutboundHandler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ChannelOutboundInvoker.html">ChannelOutboundInvoker</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ContiguousCollection.html">ContiguousCollection</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/EventLoop.html">EventLoop</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/EventLoopGroup.html">EventLoopGroup</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/MessageToByteEncoder.html">MessageToByteEncoder</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/RecvByteBufferAllocator.html">RecvByteBufferAllocator</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/Resolver.html">Resolver</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/_ChannelInboundHandler.html">_ChannelInboundHandler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/_ChannelOutboundHandler.html">_ChannelOutboundHandler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/_EmittingChannelHandler.html">_EmittingChannelHandler</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/AdaptiveRecvByteBufferAllocator.html">AdaptiveRecvByteBufferAllocator</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/AddressedEnvelope.html">AddressedEnvelope</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/ByteBuffer.html">ByteBuffer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/ByteBufferAllocator.html">ByteBufferAllocator</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/ChannelOptions.html">ChannelOptions</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/CircularBuffer.html">CircularBuffer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/EventLoopPromise.html">EventLoopPromise</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/FileRegion.html">FileRegion</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/FixedSizeRecvByteBufferAllocator.html">FixedSizeRecvByteBufferAllocator</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/IOError.html">IOError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/IOError/FailureDescription.html">– FailureDescription</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/MarkedCircularBuffer.html">MarkedCircularBuffer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/NIOAny.html">NIOAny</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/NIOCompositeError.html">NIOCompositeError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/NIOConnectionError.html">NIOConnectionError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/NonBlockingFileIO.html">NonBlockingFileIO</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/NonBlockingFileIO/Error.html">– Error</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/Scheduled.html">Scheduled</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/SingleConnectionFailure.html">SingleConnectionFailure</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/TimeAmount.html">TimeAmount</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/WriteBufferWaterMark.html">WriteBufferWaterMark</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Typealiases.html">Type Aliases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/s:3NIO8IOVectora">IOVector</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/s:3NIO17ThreadInitializera">ThreadInitializer</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">

        <section class="section">
          <div class="section-content">
            <h1>Classes</h1>
            <p>The following classes are available globally.</p>

          </div>
        </section>

        <section class="section">
          <div class="section-content">
            <div class="task-group">
              <ul class="item-container">
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO20BlockingIOThreadPoolC"></a>
                    <a name="//apple_ref/swift/Class/BlockingIOThreadPool" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO20BlockingIOThreadPoolC">BlockingIOThreadPool</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>A thread pool that should be used for blocking IO.</p>

                        <a href="Classes/BlockingIOThreadPool.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">BlockingIOThreadPool</span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
              </ul>
            </div>
            <div class="task-group">
              <ul class="item-container">
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO15ServerBootstrapC"></a>
                    <a name="//apple_ref/swift/Class/ServerBootstrap" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO15ServerBootstrapC">ServerBootstrap</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>A <code>ServerBootstrap</code> is an easy way to bootstrap a <code>ServerChannel</code> when creating network servers.</p>

<p>Example:</p>
<pre class="highlight swift"><code>    <span class="k">let</span> <span class="nv">group</span> <span class="o">=</span> <span class="kt">MultiThreadedEventLoopGroup</span><span class="p">(</span><span class="nv">numThreads</span><span class="p">:</span> <span class="kt">System</span><span class="o">.</span><span class="n">coreCount</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">bootstrap</span> <span class="o">=</span> <span class="kt">ServerBootstrap</span><span class="p">(</span><span class="nv">group</span><span class="p">:</span> <span class="n">group</span><span class="p">)</span>
        <span class="c1">// Specify backlog and enable SO_REUSEADDR for the server itself</span>
        <span class="o">.</span><span class="nf">serverChannelOption</span><span class="p">(</span><span class="kt">ChannelOptions</span><span class="o">.</span><span class="n">backlog</span><span class="p">,</span> <span class="nv">value</span><span class="p">:</span> <span class="mi">256</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">serverChannelOption</span><span class="p">(</span><span class="kt">ChannelOptions</span><span class="o">.</span><span class="nf">socket</span><span class="p">(</span><span class="kt">SocketOptionLevel</span><span class="p">(</span><span class="kt">SOL_SOCKET</span><span class="p">),</span> <span class="kt">SO_REUSEADDR</span><span class="p">),</span> <span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1">// Set the handlers that are appled to the accepted child `Channel`s.</span>
        <span class="o">.</span><span class="n">childChannelInitializer</span> <span class="p">{</span> <span class="n">channel</span> <span class="k">in</span>
            <span class="c1">// Ensure we don't read faster then we can write by adding the BackPressureHandler into the pipeline.</span>
            <span class="n">channel</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="nv">handler</span><span class="p">:</span> <span class="kt">BackPressureHandler</span><span class="p">())</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="p">()</span> <span class="k">in</span>
                <span class="n">channel</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="nv">handler</span><span class="p">:</span> <span class="kt">MyChannelHandler</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Enable TCP_NODELAY and SO_REUSEADDR for the accepted Channels</span>
        <span class="o">.</span><span class="nf">childChannelOption</span><span class="p">(</span><span class="kt">ChannelOptions</span><span class="o">.</span><span class="nf">socket</span><span class="p">(</span><span class="kt">IPPROTO_TCP</span><span class="p">,</span> <span class="kt">TCP_NODELAY</span><span class="p">),</span> <span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">childChannelOption</span><span class="p">(</span><span class="kt">ChannelOptions</span><span class="o">.</span><span class="nf">socket</span><span class="p">(</span><span class="kt">SocketOptionLevel</span><span class="p">(</span><span class="kt">SOL_SOCKET</span><span class="p">),</span> <span class="kt">SO_REUSEADDR</span><span class="p">),</span> <span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">childChannelOption</span><span class="p">(</span><span class="kt">ChannelOptions</span><span class="o">.</span><span class="n">maxMessagesPerRead</span><span class="p">,</span> <span class="nv">value</span><span class="p">:</span> <span class="mi">16</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">childChannelOption</span><span class="p">(</span><span class="kt">ChannelOptions</span><span class="o">.</span><span class="n">recvAllocator</span><span class="p">,</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">AdaptiveRecvByteBufferAllocator</span><span class="p">())</span>
    <span class="k">defer</span> <span class="p">{</span>
        <span class="k">try!</span> <span class="n">group</span><span class="o">.</span><span class="nf">syncShutdownGracefully</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">try!</span> <span class="n">bootstrap</span><span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">host</span><span class="p">:</span> <span class="n">host</span><span class="p">,</span> <span class="nv">port</span><span class="p">:</span> <span class="n">port</span><span class="p">)</span><span class="o">.</span><span class="nf">wait</span><span class="p">()</span>
    <span class="cm">/* the server will now be accepting connections */</span>

    <span class="k">try!</span> <span class="n">channel</span><span class="o">.</span><span class="n">closeFuture</span><span class="o">.</span><span class="nf">wait</span><span class="p">()</span> <span class="c1">// wait forever as we never close the Channel</span>
</code></pre>

                        <a href="Classes/ServerBootstrap.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">ServerBootstrap</span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO15ClientBootstrapC"></a>
                    <a name="//apple_ref/swift/Class/ClientBootstrap" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO15ClientBootstrapC">ClientBootstrap</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>A <code>ClientBootstrap</code> is an easy way to bootstrap a <code>SocketChannel</code> when creating network clients.</p>

<p>Usually you re-use a <code>ClientBootstrap</code> once you set it up and called <code>connect</code> multiple times on it.
This way you ensure that the same <code><a href="Protocols/EventLoop.html">EventLoop</a></code>s will be shared across all your connections.</p>

<p>Example:</p>
<pre class="highlight swift"><code>    <span class="k">let</span> <span class="nv">group</span> <span class="o">=</span> <span class="kt">MultiThreadedEventLoopGroup</span><span class="p">(</span><span class="nv">numThreads</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">bootstrap</span> <span class="o">=</span> <span class="kt">ClientBootstrap</span><span class="p">(</span><span class="nv">group</span><span class="p">:</span> <span class="n">group</span><span class="p">)</span>
        <span class="c1">// Enable SO_REUSEADDR.</span>
        <span class="o">.</span><span class="nf">channelOption</span><span class="p">(</span><span class="kt">ChannelOptions</span><span class="o">.</span><span class="nf">socket</span><span class="p">(</span><span class="kt">SocketOptionLevel</span><span class="p">(</span><span class="kt">SOL_SOCKET</span><span class="p">),</span> <span class="kt">SO_REUSEADDR</span><span class="p">),</span> <span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">channelInitializer</span> <span class="p">{</span> <span class="n">channel</span> <span class="k">in</span>
            <span class="n">channel</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="nv">handler</span><span class="p">:</span> <span class="kt">MyChannelHandler</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="k">defer</span> <span class="p">{</span>
        <span class="k">try!</span> <span class="n">group</span><span class="o">.</span><span class="nf">syncShutdownGracefully</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">try!</span> <span class="n">bootstrap</span><span class="o">.</span><span class="nf">connect</span><span class="p">(</span><span class="nv">host</span><span class="p">:</span> <span class="s">"example.org"</span><span class="p">,</span> <span class="nv">port</span><span class="p">:</span> <span class="mi">12345</span><span class="p">)</span><span class="o">.</span><span class="nf">wait</span><span class="p">()</span>
    <span class="cm">/* the Channel is now connected */</span>
</code></pre>

                        <a href="Classes/ClientBootstrap.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">ClientBootstrap</span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO17DatagramBootstrapC"></a>
                    <a name="//apple_ref/swift/Class/DatagramBootstrap" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO17DatagramBootstrapC">DatagramBootstrap</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>A <code>DatagramBootstrap</code> is an easy way to bootstrap a <code>DatagramChannel</code> when creating datagram clients
and servers.</p>

<p>Example:</p>
<pre class="highlight swift"><code>    <span class="k">let</span> <span class="nv">group</span> <span class="o">=</span> <span class="kt">MultiThreadedEventLoopGroup</span><span class="p">(</span><span class="nv">numThreads</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">bootstrap</span> <span class="o">=</span> <span class="kt">DatagramBootstrap</span><span class="p">(</span><span class="nv">group</span><span class="p">:</span> <span class="n">group</span><span class="p">)</span>
        <span class="c1">// Enable SO_REUSEADDR.</span>
        <span class="o">.</span><span class="nf">channelOption</span><span class="p">(</span><span class="kt">ChannelOptions</span><span class="o">.</span><span class="nf">socket</span><span class="p">(</span><span class="kt">SocketOptionLevel</span><span class="p">(</span><span class="kt">SOL_SOCKET</span><span class="p">),</span> <span class="kt">SO_REUSEADDR</span><span class="p">),</span> <span class="nv">value</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">channelInitializer</span> <span class="p">{</span> <span class="n">channel</span> <span class="k">in</span>
            <span class="n">channel</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="nf">add</span><span class="p">(</span><span class="nv">handler</span><span class="p">:</span> <span class="kt">MyChannelHandler</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="k">defer</span> <span class="p">{</span>
        <span class="k">try!</span> <span class="n">group</span><span class="o">.</span><span class="nf">syncShutdownGracefully</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">channel</span> <span class="o">=</span> <span class="k">try!</span> <span class="n">bootstrap</span><span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="nv">host</span><span class="p">:</span> <span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="nv">port</span><span class="p">:</span> <span class="mi">53</span><span class="p">)</span><span class="o">.</span><span class="nf">wait</span><span class="p">()</span>
    <span class="cm">/* the Channel is now ready to send/receive datagrams */</span>

    <span class="k">try</span> <span class="n">channel</span><span class="o">.</span><span class="n">closeFuture</span><span class="o">.</span><span class="nf">wait</span><span class="p">()</span>  <span class="c1">// Wait until the channel un-binds.</span>
</code></pre>

                        <a href="Classes/DatagramBootstrap.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">DatagramBootstrap</span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
              </ul>
            </div>
            <div class="task-group">
              <ul class="item-container">
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO19BackPressureHandlerC"></a>
                    <a name="//apple_ref/swift/Class/BackPressureHandler" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO19BackPressureHandlerC">BackPressureHandler</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>ChannelHandler implementation which enforces back-pressure by stopping to read from the remote peer when it cannot write back fast enough.
It will start reading again once pending data was written.</p>

                        <a href="Classes/BackPressureHandler.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">BackPressureHandler</span><span class="p">:</span> <span class="kt"><a href="Protocols/ChannelInboundHandler.html">ChannelInboundHandler</a></span><span class="p">,</span> <span class="n"><a href="Protocols/_ChannelOutboundHandler.html">_ChannelOutboundHandler</a></span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO16IdleStateHandlerC"></a>
                    <a name="//apple_ref/swift/Class/IdleStateHandler" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO16IdleStateHandlerC">IdleStateHandler</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>Triggers an IdleStateEvent when a Channel has not performed read, write, or both operation for a while.</p>

                        <a href="Classes/IdleStateHandler.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">IdleStateHandler</span><span class="p">:</span> <span class="kt"><a href="Protocols/ChannelInboundHandler.html">ChannelInboundHandler</a></span><span class="p">,</span> <span class="kt"><a href="Protocols/ChannelOutboundHandler.html">ChannelOutboundHandler</a></span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
              </ul>
            </div>
            <div class="task-group">
              <ul class="item-container">
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO15ChannelPipelineC"></a>
                    <a name="//apple_ref/swift/Class/ChannelPipeline" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO15ChannelPipelineC">ChannelPipeline</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>&ldquo;A list of <code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code>s that handle or intercept inbound events and outbound operations of a
<code><a href="Protocols/Channel.html">Channel</a></code>. <code>ChannelPipeline</code> implements an advanced form of the Intercepting Filter pattern
to give a user full control over how an event is handled and how the <code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code>s in a pipeline
interact with each other.</p>
<h1 id='creation-of-a-pipeline' class='heading'>Creation of a pipeline</h1>

<p>Each <code><a href="Protocols/Channel.html">Channel</a></code> has its own <code>ChannelPipeline</code> and it is created automatically when a new <code><a href="Protocols/Channel.html">Channel</a></code> is created.</p>
<h1 id='how-an-event-flows-in-a-pipeline' class='heading'>How an event flows in a pipeline</h1>

<p>The following diagram describes how I/O events are typically processed by <code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code>s in a <code>ChannelPipeline</code>.
An I/O event is handled by either a <code><a href="Protocols/ChannelInboundHandler.html">ChannelInboundHandler</a></code> or a <code><a href="Protocols/ChannelOutboundHandler.html">ChannelOutboundHandler</a></code>
and is forwarded to the next handler in the <code>ChannelPipeline</code> by calling the event propagation methods defined in
<code><a href="Classes/ChannelHandlerContext.html">ChannelHandlerContext</a></code>, such as <code>ChannelHandlerContext.fireChannelRead</code> and
<code>ChannelHandlerContext.write</code>.</p>
<pre class="highlight plaintext"><code>                                                   I/O Request
                                                   via `Channel` or
                                                   `ChannelHandlerContext`
                                                     |
 +---------------------------------------------------+---------------+
 |                           ChannelPipeline         |               |
 |                                TAIL              \|/              |
 |    +---------------------+            +-----------+----------+    |
 |    | Inbound Handler  N  |            | Outbound Handler  1  |    |
 |    +----------+----------+            +-----------+----------+    |
 |              /|\                                  |               |
 |               |                                  \|/              |
 |    +----------+----------+            +-----------+----------+    |
 |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |
 |    +----------+----------+            +-----------+----------+    |
 |              /|\                                  .               |
 |               .                                   .               |
 | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
 |        [ method call]                       [method call]         |
 |               .                                   .               |
 |               .                                  \|/              |
 |    +----------+----------+            +-----------+----------+    |
 |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |
 |    +----------+----------+            +-----------+----------+    |
 |              /|\                                  |               |
 |               |                                  \|/              |
 |    +----------+----------+            +-----------+----------+    |
 |    | Inbound Handler  1  |            | Outbound Handler  M  |    |
 |    +----------+----------+            +-----------+----------+    |
 |              /|\             HEAD                 |               |
 +---------------+-----------------------------------+---------------+
                 |                                  \|/
 +---------------+-----------------------------------+---------------+
 |               |                                   |               |
 |       [ Socket.read ]                    [ Socket.write ]         |
 |                                                                   |
 |  SwiftNIO Internal I/O Threads (Transport Implementation)           |
 +-------------------------------------------------------------------+
</code></pre>

<p>An inbound event is handled by the inbound handlers in the head-to-tail direction as shown on the left side of the
diagram. An inbound handler usually handles the inbound data generated by the I/O thread on the bottom of the
diagram. The inbound data is often read from a remote peer via the actual input operation such as
<code>Socket.read</code>. If an inbound event goes beyond the tail inbound handler, it is discarded
silently, or logged if it needs your attention.</p>

<p>An outbound event is handled by the outbound handlers in the tail-to-head direction as shown on the right side of the
diagram. An outbound handler usually generates or transforms the outbound traffic such as write requests.
If an outbound event goes beyond the head outbound handler, it is handled by an I/O thread associated with the
<code><a href="Protocols/Channel.html">Channel</a></code>. The I/O thread often performs the actual output operation such as <code>Socket.write</code>.</p>

<p>For example, let us assume that we created the following pipeline:</p>
<pre class="highlight plaintext"><code>ChannelPipeline p = ...
let future = p.add(name: "1", handler: InboundHandlerA()).then {
  p.add(name: "2", handler: InboundHandlerB())
}.then {
  p.add(name: "3", handler: OutboundHandlerA())
}.then {
  p.add(name: "4", handler: OutboundHandlerB())
}.then {
  p.add(name: "5", handler: InboundOutboundHandlerX())
}
// Handle the future as well ....
</code></pre>

<p>In the example above, a class whose name starts with <code>Inbound</code> is an inbound handler.
A class whose name starts with <code>Outbound</code> is an outbound handler.</p>

<p>In the given example configuration, the handler evaluation order is 1, 2, 3, 4, 5 when an event goes inbound.
When an event goes outbound, the order is 5, 4, 3, 2, 1.  On top of this principle, <code>ChannelPipeline</code> skips
the evaluation of certain handlers to shorten the stack depth:</p>

<ul>
<li>3 and 4 don&rsquo;t implement <code><a href="Protocols/ChannelInboundHandler.html">ChannelInboundHandler</a></code>, and therefore the actual evaluation order of an inbound event will be: 1, 2, and 5.</li>
<li>1 and 2 don&rsquo;t implement <code><a href="Protocols/ChannelOutboundHandler.html">ChannelOutboundHandler</a></code>, and therefore the actual evaluation order of a outbound event will be: 5, 4, and 3.</li>
<li>If 5 implements both <code><a href="Protocols/ChannelInboundHandler.html">ChannelInboundHandler</a></code> and <code><a href="Protocols/ChannelOutboundHandler.html">ChannelOutboundHandler</a></code>, the evaluation order of an inbound and a outbound event could be 125 and 543 respectively.</li>
</ul>
<h1 id='forwarding-an-event-to-the-next-handler' class='heading'>Forwarding an event to the next handler</h1>

<p>As you might noticed in the diagram above, a handler has to invoke the event propagation methods in
<code><a href="Classes/ChannelHandlerContext.html">ChannelHandlerContext</a></code> to forward an event to its next handler.
Those methods include:</p>

<ul>
<li>Inbound event propagation methods defined in <code><a href="Protocols/ChannelInboundInvoker.html">ChannelInboundInvoker</a></code></li>
<li>Outbound event propagation methods defined in <code><a href="Protocols/ChannelOutboundInvoker.html">ChannelOutboundInvoker</a></code>.</li>
</ul>
<h1 id='building-a-pipeline' class='heading'>Building a pipeline</h1>

<p>A user is supposed to have one or more <code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code>s in a <code>ChannelPipeline</code> to receive I/O events (e.g. read) and
to request I/O operations (e.g. write and close).  For example, a typical server will have the following handlers
in each channel&rsquo;s pipeline, but your mileage may vary depending on the complexity and characteristics of the
protocol and business logic:</p>

<ul>
<li>Protocol Decoder - translates binary data (e.g. <code><a href="Structs/ByteBuffer.html">ByteBuffer</a></code>) into a struct / class</li>
<li>Protocol Encoder - translates a struct / class into binary data (e.g. <code><a href="Structs/ByteBuffer.html">ByteBuffer</a></code>)</li>
<li>Business Logic Handler - performs the actual business logic (e.g. database access)</li>
</ul>
<h1 id='thread-safety' class='heading'>Thread safety</h1>

<p>A <code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code> can be added or removed at any time because a <code>ChannelPipeline</code> is thread safe.</p>

                        <a href="Classes/ChannelPipeline.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">ChannelPipeline</span><span class="p">:</span> <span class="kt"><a href="Protocols.html#/s:3NIO14ChannelInvokerP">ChannelInvoker</a></span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO21ChannelHandlerContextC"></a>
                    <a name="//apple_ref/swift/Class/ChannelHandlerContext" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO21ChannelHandlerContextC">ChannelHandlerContext</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>Every <code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code> has &ndash; when added to a <code><a href="Classes/ChannelPipeline.html">ChannelPipeline</a></code> &ndash; a corresponding <code>ChannelHandlerContext</code> which is
the way <code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code>s can interact with other <code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code>s in the pipeline.</p>

<p>Most <code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code>s need to send events through the <code><a href="Classes/ChannelPipeline.html">ChannelPipeline</a></code> which they do by calling the respective
method on their <code>ChannelHandlerContext</code>. In fact all the <code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code> default implementations just forward
the event using the <code>ChannelHandlerContext</code>.</p>

<p>Many events are instrumental for a <code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code>&lsquo;s life-cycle and it is therefore very important to send them
at the right point in time. Often, the right behaviour is to react to an event and then forward it to the next
<code><a href="Protocols/ChannelHandler.html">ChannelHandler</a></code>.</p>

                        <a href="Classes/ChannelHandlerContext.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">ChannelHandlerContext</span><span class="p">:</span> <span class="kt"><a href="Protocols.html#/s:3NIO14ChannelInvokerP">ChannelInvoker</a></span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
              </ul>
            </div>
            <div class="task-group">
              <ul class="item-container">
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO17EmbeddedEventLoopC"></a>
                    <a name="//apple_ref/swift/Class/EmbeddedEventLoop" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO17EmbeddedEventLoopC">EmbeddedEventLoop</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>An <code><a href="Protocols/EventLoop.html">EventLoop</a></code> that is embedded in the current running context with no external
control.</p>

<p>Unlike more complex <code><a href="Protocols/EventLoop.html">EventLoop</a></code>s, such as <code>SelectableEventLoop</code>, the <code>EmbeddedEventLoop</code>
has no proper eventing mechanism. Instead, reads and writes are fully controlled by the
entity that instantiates the <code>EmbeddedEventLoop</code>. This property makes <code>EmbeddedEventLoop</code>
of limited use for many application purposes, but highly valuable for testing and other
kinds of mocking.</p>
<div class="aside aside-warning">
    <p class="aside-title">Warning</p>
    Unlike <code>SelectableEventLoop</code>, <code>EmbeddedEventLoop</code> <strong>is not thread-safe</strong>. This
is becuase it is intended to be run in the thread that instantiated it. Users are
responsible for ensuring they never call into the <code>EmbeddedEventLoop</code> in an
unsynchronized fashion.

</div>

                        <a href="Classes/EmbeddedEventLoop.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">EmbeddedEventLoop</span><span class="p">:</span> <span class="kt"><a href="Protocols/EventLoop.html">EventLoop</a></span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO15EmbeddedChannelC"></a>
                    <a name="//apple_ref/swift/Class/EmbeddedChannel" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO15EmbeddedChannelC">EmbeddedChannel</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>Undocumented</p>

                        <a href="Classes/EmbeddedChannel.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">EmbeddedChannel</span><span class="p">:</span> <span class="kt"><a href="Protocols/Channel.html">Channel</a></span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
              </ul>
            </div>
            <div class="task-group">
              <ul class="item-container">
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO27MultiThreadedEventLoopGroupC"></a>
                    <a name="//apple_ref/swift/Class/MultiThreadedEventLoopGroup" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO27MultiThreadedEventLoopGroupC">MultiThreadedEventLoopGroup</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>An <code><a href="Protocols/EventLoopGroup.html">EventLoopGroup</a></code> which will create multiple <code><a href="Protocols/EventLoop.html">EventLoop</a></code>s, each tied to its own <code>Thread</code>.</p>

                        <a href="Classes/MultiThreadedEventLoopGroup.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">final</span> <span class="kd">public</span> <span class="kd">class</span> <span class="kt">MultiThreadedEventLoopGroup</span><span class="p">:</span> <span class="kt"><a href="Protocols/EventLoopGroup.html">EventLoopGroup</a></span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
              </ul>
            </div>
            <div class="task-group">
              <ul class="item-container">
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO15EventLoopFutureC"></a>
                    <a name="//apple_ref/swift/Class/EventLoopFuture" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO15EventLoopFutureC">EventLoopFuture</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>Holder for a result that will be provided later.</p>

<p>Functions that promise to do work asynchronously can return an <code>EventLoopFuture&lt;T&gt;</code>.
The recipient of such an object can then observe it to be notified when the operation completes.</p>

<p>The provider of a <code>EventLoopFuture&lt;T&gt;</code> can create and return a placeholder object
before the actual result is available. For example:</p>
<pre class="highlight plaintext"><code>func getNetworkData(args) -&gt; EventLoopFuture&lt;NetworkResponse&gt; {
    let promise: EventLoopPromise&lt;NetworkResponse&gt; = eventLoop.newPromise()
    queue.async {
        . . . do some work . . .
        promise.succeed(response)
        . . . if it fails, instead . . .
        promise.fail(error)
    }
    return promise.futureResult
}
</code></pre>

<p>Note that this function returns immediately; the promise object will be given a value
later on. This behaviour is common to Future/Promise implementations in many programming
languages. If you are unfamiliar with this kind of object, the following resources may be
helpful:</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">Javascript</a></li>
<li><a href="http://docs.scala-lang.org/overviews/core/futures.html">Scala</a></li>
<li><a href="https://docs.google.com/document/d/10WOZgLQaYNpOrag-eTbUm-JUCCfdyfravZ4qSOQPg1M/edit">Python</a></li>
</ul>

<p>If you receive a <code>EventLoopFuture&lt;T&gt;</code> from another function, you have a number of options:
The most common operation is to use <code>then()</code> or <code>map()</code> to add a function that will be called
with the eventual result.  Both methods returns a new <code>EventLoopFuture&lt;T&gt;</code> immediately
that will receive the return value from your function, but they behave differently. If you have
a function that can return synchronously, the <code>map</code> function will transform the result <code>T</code> to a
the new result value <code>U</code> and return an <code>EventLoopFuture&lt;U&gt;</code>.</p>
<pre class="highlight plaintext"><code>let networkData = getNetworkData(args)

// When network data is received, convert it.
let processedResult: EventLoopFuture&lt;Processed&gt; = networkData.map { (n: NetworkResponse) -&gt; Processed in
    ... parse network data ....
    return processedResult
}
</code></pre>

<p>If however you need to do more asynchronous processing, you can call <code>then()</code>. The return value of the
function passed to <code>then</code> must be a new <code>EventLoopFuture&lt;U&gt;</code> object: the return value of <code>then()</code> is
a new <code>EventLoopFuture&lt;U&gt;</code> that will contain the eventual result of both the original operation and
the subsequent one.</p>
<pre class="highlight plaintext"><code>// When converted network data is available, begin the database operation.
let databaseResult: EventLoopFuture&lt;DBResult&gt; = processedResult.then { (p: Processed) -&gt; EventLoopFuture&lt;DBResult&gt; in
    return someDatabaseOperation(p)
}
</code></pre>

<p>In essence, future chains created via <code>then()</code> provide a form of data-driven asynchronous programming
that allows you to dynamically declare data dependencies for your various operations.</p>

<p><code>EventLoopFuture</code> chains created via <code>then()</code> are sufficient for most purposes. All of the registered
functions will eventually run in order. If one of those functions throws an error, that error will
bypass the remaining functions. You can use <code>thenIfError()</code> to handle and optionally recover from
errors in the middle of a chain.</p>

<p>At the end of an <code>EventLoopFuture</code> chain, you can use <code>whenSuccess()</code> or <code>whenFailure()</code> to add an
observer callback that will be invoked with the result or error at that point. (Note: If you ever
find yourself invoking <code>promise.succeed()</code> from inside a <code>whenSuccess()</code> callback, you probably should
use <code>then()</code> or <code>cascade(promise:)</code> instead.)</p>

<p><code>EventLoopFuture</code> objects are typically obtained by:</p>

<ul>
<li>Using <code>EventLoopFuture&lt;T&gt;.async</code> or a similar wrapper function.</li>
<li>Using <code>.then()</code> on an existing future to create a new future for the next step in a series of operations.</li>
<li>Initializing an <code>EventLoopFuture</code> that already has a value or an error</li>
</ul>

                        <a href="Classes/EventLoopFuture.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">EventLoopFuture</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
              </ul>
            </div>
            <div class="task-group">
              <ul class="item-container">
                <li class="item">
                  <div>
                    <code>
                    <a name="/s:3NIO10FileHandleC"></a>
                    <a name="//apple_ref/swift/Class/FileHandle" class="dashAnchor"></a>
                    <a class="token" href="#/s:3NIO10FileHandleC">FileHandle</a>
                    </code>
                  </div>
                  <div class="height-container">
                    <div class="pointer-container"></div>
                    <section class="section">
                      <div class="pointer"></div>
                      <div class="abstract">
                        <p>A <code>FileHandle</code> is a handle to an open file.</p>

<p>When creating a <code>FileHandle</code> it takes ownership of the underlying file descriptor. When a <code>FileHandle</code> is no longer
needed you must <code>close</code> it or take back ownership of the file descriptor using <code>takeDescriptorOwnership</code>.</p>
<div class="aside aside-note">
    <p class="aside-title">Note</p>
    <p>One underlying file descriptor should usually be managed by one <code>FileHandle</code> only.</p>

</div>
<div class="aside aside-warning">
    <p class="aside-title">Warning</p>
    <p>Failing to manage the lifetime of a <code>FileHandle</code> correctly will result in undefined behaviour.</p>

</div>
<div class="aside aside-warning">
    <p class="aside-title">Warning</p>
    <p><code>FileHandle</code> objects are not thread-safe and are mutable. They also cannot be fully thread-safe as they refer to a global underlying file descriptor.</p>

</div>

                        <a href="Classes/FileHandle.html" class="slightly-smaller">See more</a>
                      </div>
                      <div class="declaration">
                        <h4>Declaration</h4>
                        <div class="language">
                          <p class="aside-title">Swift</p>
                          <pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">FileHandle</span></code></pre>

                        </div>
                      </div>
                    </section>
                  </div>
                </li>
              </ul>
            </div>
          </div>
        </section>

      </article>
    </div>
    <section class="footer">
      <p>&copy; 2018 <a class="link" href="https://github.com/apple/swift-nio" target="_blank" rel="external">SwiftNIO Team</a>. All rights reserved. (Last updated: 2018-02-26)</p>
      <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.9.0</a>, a <a class="link" href="http://realm.io" target="_blank" rel="external">Realm</a> project.</p>
    </section>
  </body>
</div>
</html>
